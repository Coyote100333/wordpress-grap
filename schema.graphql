schema {
  query: RootQuery
  mutation: RootMutation
}

# Avatars are profile images for users. WordPress by default uses the Gravatar service to host and fetch avatars from.
type Avatar {
  # URL for the default image or a default type. Accepts &#039;404&#039; (return a
  # 404 instead of a default image), &#039;retro&#039; (8bit),
  # &#039;monsterid&#039; (monster), &#039;wavatar&#039; (cartoon face),
  # &#039;indenticon&#039; (the &#039;quilt&#039;), &#039;mystery&#039;,
  # &#039;mm&#039;, or &#039;mysteryman&#039; (The Oyster Man), &#039;blank&#039;
  # (transparent GIF), or &#039;gravatar_default&#039; (the Gravatar logo).
  default: String

  # HTML attributes to insert in the IMG element. Is not sanitized.
  extraAttr: String

  # Whether to always show the default image, never the Gravatar.
  forceDefault: Boolean

  # Whether the avatar was successfully found.
  foundAvatar: Boolean

  # Height of the avatar image.
  height: Int

  # What rating to display avatars up to. Accepts &#039;G&#039;, &#039;PG&#039;,
  # &#039;R&#039;, &#039;X&#039;, and are judged in that order.
  rating: String

  # Type of url scheme to use. Typically HTTP vs. HTTPS.
  scheme: String

  # The size of the avatar in pixels. A value of 96 will match a 96px x 96px gravatar image.
  size: Int

  # URL for the gravatar image source.
  url: String

  # Width of the avatar image.
  width: Int
}

# What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are
# judged in that order. Default is the value of the 'avatar_rating' option
enum AvatarRatingEnum {
  G
  PG
  R
  X
}

# A connection to a list of items.
type CategoriesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [CategoriesEdge]

  # Information about the type of content being queried
  taxonomyInfo: Taxonomy

  # The nodes of the connection, without the edges
  nodes: [Category]
}

# An edge in a connection
type CategoriesEdge {
  # The item at the end of the edge
  node: Category

  # A cursor for use in pagination
  cursor: String!
}

# The 0bject type
type Category implements Node {
  # The ancestors of the object
  ancestors: [Category]

  # The id field matches the WP_Post-&gt;ID field.
  categoryId: Int

  # A collection of categories objects
  children(after: String, first: Int, before: String, last: Int, where: TermArgs): CategoriesConnection

  # The number of objects connected to the object
  count: Int

  # The description of the object
  description: String

  # The global ID for the category
  id: ID!

  # The link to the term
  link: String

  # The human friendly name of the object.
  name: String

  # The parent object
  parent: Category

  # A collection of posts objects
  posts(after: String, first: Int, before: String, last: Int, where: QueryArgs): PostsConnection

  # An alphanumeric identifier for the object unique to its type.
  slug: String

  # The name of the taxonomy this term belongs to
  taxonomy: Taxonomy

  # The ID of the term group that this term object belongs to
  termGroupId: Int

  # The taxonomy ID that the object is associated with
  termTaxonomyId: Int
}

# A Comment object
type Comment implements Node {
  # User agent used to post the comment. This field is equivalent to
  # WP_Comment-&gt;comment_agent and the value matching the `comment_agent` column
  agent: String

  # The approval status of the comment. This field is equivalent to
  # WP_Comment-&gt;comment_approved and the value matching the `comment_approved`
  approved: String

  # The author of the comment
  author: CommentAuthorUnion

  # IP address for the author. This field is equivalent to
  # WP_Comment-&gt;comment_author_IP and the value matching the
  # `comment_author_IP` column in SQL.
  authorIp: String

  # A collection of comment objects
  children(after: String, first: Int, before: String, last: Int, where: CommentArgs): CommentsConnection

  # ID for the comment, unique among comments.
  commentId: Int

  # The object the comment was added to
  commentedOn: PostObjectUnion

  # Content of the comment. This field is equivalent to
  # WP_Comment-&gt;comment_content and the value matching the `comment_content`
  content: String

  # Date the comment was posted in local time. This field is equivalent to
  # WP_Comment-&gt;date and the value matching the `date` column in SQL.
  date: String

  # Date the comment was posted in GMT. This field is equivalent to
  # WP_Comment-&gt;date_gmt and the value matching the `date_gmt` column in SQL.
  dateGmt: String

  # The globally unique identifier for the user
  id: ID!

  # Karma value for the comment. This field is equivalent to
  # WP_Comment-&gt;comment_karma and the value matching the `comment_karma` column
  karma: Int

  # Parent comment of current comment. This field is equivalent to the WP_Comment
  # instance matching the WP_Comment-&gt;comment_parent ID.
  parent: Comment

  # Type of comment. This field is equivalent to WP_Comment-&gt;comment_type and
  # the value matching the `comment_type` column in SQL.
  type: String
}

input CommentArgs {
  # Comment author email address.
  authorEmail: String

  # Array of author IDs to include comments for.
  authorIn: [Int]

  # Array of author IDs to exclude comments for.
  authorNotIn: [Int]

  # Comment author URL.
  authorUrl: String

  # Array of comment IDs to include.
  commentIn: [Int]

  # Array of IDs of users whose unapproved comments will be returned by the 
  # 							query regardless of status.
  commentNotIn: [Int]

  # Include comments of a given type.
  commentType: String

  # Include comments from a given array of comment types.
  commentTypeIn: [String]

  # Exclude comments from a given array of comment types.
  commentTypeNotIn: String

  # Content object author ID to limit results by.
  contentAuthor: [Int]

  # Array of author IDs to retrieve comments for.
  contentAuthorIn: [Int]

  # Array of author IDs *not* to retrieve comments for.
  contentAuthorNotIn: [Int]

  # Limit results to those affiliated with a given content object 
  # 							ID.
  contentId: Int

  # Array of content object IDs to include affiliated comments 
  # 							for.
  contentIdIn: [Int]

  # Array of content object IDs to exclude affiliated comments 
  # 							for.
  contentIdNotIn: [Int]

  # Content object name to retrieve affiliated comments for.
  contentName: String

  # Content Object parent ID to retrieve affiliated comments for.
  contentParent: Int

  # Array of content object statuses to retrieve affiliated comments for. 
  # 							Pass 'any' to match any value.
  contentStatus: [PostStatusEnum]

  # Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value.
  contentType: [PostTypeEnum]

  # Array of author IDs to include comments for.
  includeUnapproved: [Int]

  # Karma score to retrieve matching comments for.
  karma: Int
  order: CommentsOrder

  # Field to order the comments by.
  orderby: CommentsOrderby

  # Parent ID of comment to retrieve children of.
  parent: Int

  # Array of parent IDs of comments to retrieve children for.
  parentIn: [Int]

  # Array of parent IDs of comments *not* to retrieve children 
  # 							for.
  parentNotIn: [Int]

  # Search term(s) to retrieve matching comments for.
  search: String

  # Comment status to limit results by.
  status: String

  # Include comments for a specific user ID.
  userId: Int
}

# A Comment Author object
type CommentAuthor implements Node {
  # The email for the comment author
  email: String

  # The globally unique identifier for the Comment Author user
  id: ID!

  # The name for the comment author.
  name: String

  # The url the comment author.
  url: String
}

union CommentAuthorUnion = User | CommentAuthor

# A connection to a list of items.
type CommentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [CommentsEdge]

  # The nodes of the connection, without the edges
  nodes: [Comment]
}

# An edge in a connection
type CommentsEdge {
  # The item at the end of the edge
  node: Comment

  # A cursor for use in pagination
  cursor: String!
}

enum CommentsOrder {
  ASC
  DESC
}

enum CommentsOrderby {
  COMMENT_AGENT
  COMMENT_APPROVED
  COMMENT_AUTHOR
  COMMENT_AUTHOR_EMAIL
  COMMENT_AUTHOR_IP
  COMMENT_AUTHOR_URL
  COMMENT_CONTENT
  COMMENT_DATE
  COMMENT_DATE_GMT
  COMMENT_ID
  COMMENT_IN
  COMMENT_KARMA
  COMMENT_PARENT
  COMMENT_POST_ID
  COMMENT_TYPE
  USER_ID
}

input CreateCategoryInput {
  # The name of the category object to mutate
  name: String

  # The slug that the category will be an alias of
  aliasOf: String

  # The description of the category object
  description: String

  # If this argument exists then the slug will be checked to see if it is not an
  # existing valid term. If that check succeeds (it is not a valid term), then it
  # is added and the term id is given. If it fails, then a check is made to
  # whether the taxonomy is hierarchical and the parent argument is not empty. If
  # the second check succeeds, the term will be inserted and the term id will be
  # given. If the slug argument is empty, then it will be calculated from the term
  slug: String

  # The ID of the category that should be set as the parent
  parentId: ID
  clientMutationId: String!
}

type CreateCategoryPayload {
  # The created category
  category: Category
  clientMutationId: String!
}

input CreateMediaItemInput {
  # The file name of the mediaItem
  filePath: String

  # Alternative text to display when mediaItem is not displayed
  altText: String

  # The userId to assign as the author of the mediaItem
  authorId: ID

  # The caption for the mediaItem
  caption: String

  # The comment status for the mediaItem
  commentStatus: String

  # The date of the mediaItem
  date: String

  # The date (in GMT zone) of the mediaItem
  dateGmt: String

  # Description of the mediaItem
  description: String

  # The file type of the mediaItem
  fileType: MimeType

  # The slug of the mediaItem
  slug: String

  # The status of the mediaItem
  status: MediaItemStatus

  # The title of the mediaItem
  title: String

  # The ping status for the mediaItem
  pingStatus: String

  # The WordPress post ID or the graphQL postId of the parent object
  parentId: ID
  clientMutationId: String!
}

type CreateMediaItemPayload {
  mediaItem: MediaItem
  clientMutationId: String!
}

input CreatePageInput {
  # The userId to assign as the author of the post
  authorId: ID

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # The comment status for the object
  commentStatus: String

  # The content of the object
  content: String

  # The date of the object
  date: String

  # The date (in GMT zone) of the object
  dateGmt: String

  # The excerpt of the object
  excerpt: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # If the post is an attachment or a media file, this field will carry the
  # corresponding MIME type. This field is equivalent to the value of
  # WP_Post->post_mime_type and the post_mime_type column in the `post_objects`
  # database table.
  mimeType: MimeType

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The ID of the parent object
  parentId: ID

  # The password used to protect the content of the object
  password: String

  # URLs that have been pinged.
  pinged: [String]

  # The ping status for the object
  pingStatus: String

  # The slug of the object
  slug: String

  # The status of the object
  status: PostStatusEnum

  # The title of the post
  title: String

  # URLs queued to be pinged.
  toPing: [String]
  clientMutationId: String!
}

type CreatePagePayload {
  page: Page
  clientMutationId: String!
}

input CreatePostInput {
  # The userId to assign as the author of the post
  authorId: ID

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # The comment status for the object
  commentStatus: String

  # The content of the object
  content: String

  # The date of the object
  date: String

  # The date (in GMT zone) of the object
  dateGmt: String

  # The excerpt of the object
  excerpt: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # If the post is an attachment or a media file, this field will carry the
  # corresponding MIME type. This field is equivalent to the value of
  # WP_Post->post_mime_type and the post_mime_type column in the `post_objects`
  # database table.
  mimeType: MimeType

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The ID of the parent object
  parentId: ID

  # The password used to protect the content of the object
  password: String

  # URLs that have been pinged.
  pinged: [String]

  # The ping status for the object
  pingStatus: String

  # The slug of the object
  slug: String

  # The status of the object
  status: PostStatusEnum

  # The title of the post
  title: String

  # URLs queued to be pinged.
  toPing: [String]
  clientMutationId: String!
}

type CreatePostPayload {
  post: Post
  clientMutationId: String!
}

input CreateTagInput {
  # The name of the post_tag object to mutate
  name: String

  # The slug that the post_tag will be an alias of
  aliasOf: String

  # The description of the post_tag object
  description: String

  # If this argument exists then the slug will be checked to see if it is not an
  # existing valid term. If that check succeeds (it is not a valid term), then it
  # is added and the term id is given. If it fails, then a check is made to
  # whether the taxonomy is hierarchical and the parent argument is not empty. If
  # the second check succeeds, the term will be inserted and the term id will be
  # given. If the slug argument is empty, then it will be calculated from the term
  slug: String
  clientMutationId: String!
}

type CreateTagPayload {
  # The created post_tag
  tag: Tag
  clientMutationId: String!
}

input CreateUserInput {
  # A string that contains the plain text password for the user.
  password: String

  # A string that contains a URL-friendly name for the user. The default is the user's username.
  nicename: String

  # A string containing the user's URL for the user's web site.
  websiteUrl: String

  # A string containing the user's email address.
  email: String

  # A string that will be shown on the site. Defaults to user's username. It is
  # likely that you will want to change this, for both appearance and security
  # through obscurity (that is if you dont use and delete the default admin user).
  displayName: String

  # The user's nickname, defaults to the user's username.
  nickname: String

  # 	The user's first name.
  firstName: String

  # The user's last name.
  lastName: String

  # A string containing content about the user.
  description: String

  # A string for whether to enable the rich editor or not. False if not empty.
  richEditing: String

  # The date the user registered. Format is Y-m-d H:i:s.
  registered: String

  # An array of roles to be assigned to the user.
  roles: [String]

  # User's Jabber account.
  jabber: String

  # User's AOL IM account.
  aim: String

  # User's Yahoo IM account.
  yim: String

  # User's locale.
  locale: String

  # A string that contains the user's username for logging in.
  username: String!
  clientMutationId: String!
}

type CreateUserPayload {
  user: User
  clientMutationId: String!
}

input DateAfter {
  # Day of the month (from 1 to 31)
  day: Int

  # Month number (from 1 to 12)
  month: Int

  # 4 digit year (e.g. 2017)
  year: Int
}

input DateBefore {
  # Day of the month (from 1 to 31)
  day: Int

  # Month number (from 1 to 12)
  month: Int

  # 4 digit year (e.g. 2017)
  year: Int
}

enum DateColumn {
  DATE
  MODIFIED
}

input DateQuery {
  after: DateAfter
  before: DateBefore

  # Column to query against
  column: DateColumn

  # For after/before, whether exact value should be matched or not
  compare: String

  # Day of the month (from 1 to 31)
  day: Int

  # Hour (from 0 to 23)
  hour: Int

  # For after/before, whether exact value should be matched or not
  inclusive: Boolean

  # Minute (from 0 to 59)
  minute: Int

  # Month number (from 1 to 12)
  month: Int

  # OR or AND, how the sub-arrays should be compared
  relation: RelationEnum

  # Second (0 to 59)
  second: Int

  # Week of the year (from 0 to 53)
  week: Int

  # 4 digit year (e.g. 2017)
  year: Int
}

input DeleteCategoryInput {
  # The ID of the category to delete
  id: ID!
  clientMutationId: String!
}

type DeleteCategoryPayload {
  # The ID of the deleted object
  deletedId: ID

  # The object before it was deleted
  category: Category
  clientMutationId: String!
}

input DeleteMediaItemInput {
  # The ID of the mediaItem to delete
  id: ID!

  # Whether the mediaItem should be force deleted instead of being moved to the trash
  forceDelete: Boolean
  clientMutationId: String!
}

type DeleteMediaItemPayload {
  # The ID of the deleted mediaItem
  deletedId: ID

  # The mediaItem before it was deleted
  mediaItem: MediaItem
  clientMutationId: String!
}

input DeletePageInput {
  # The ID of the page to delete
  id: ID!

  # Whether the object should be force deleted instead of being moved to the trash
  forceDelete: Boolean
  clientMutationId: String!
}

type DeletePagePayload {
  # The ID of the deleted object
  deletedId: ID

  # The object before it was deleted
  page: Page
  clientMutationId: String!
}

input DeletePostInput {
  # The ID of the post to delete
  id: ID!

  # Whether the object should be force deleted instead of being moved to the trash
  forceDelete: Boolean
  clientMutationId: String!
}

type DeletePostPayload {
  # The ID of the deleted object
  deletedId: ID

  # The object before it was deleted
  post: Post
  clientMutationId: String!
}

input DeleteTagInput {
  # The ID of the tag to delete
  id: ID!
  clientMutationId: String!
}

type DeleteTagPayload {
  # The ID of the deleted object
  deletedId: ID

  # The object before it was deleted
  tag: Tag
  clientMutationId: String!
}

input DeleteUserInput {
  # The ID of the user you want to delete
  id: ID!

  # Reassign posts and links to new User ID.
  reassignId: ID
  clientMutationId: String!
}

type DeleteUserPayload {
  # The ID of the user that you just deleted
  deletedId: ID

  # The user object for the user you are trying to delete
  user: User
  clientMutationId: String!
}

# Info on whether the object is locked by another user editing it
type EditLock {
  # The time when the object was last edited
  editTime: String

  # The user that most recently edited the object
  user: User
}

type LabelsDetails {
  # Default is ‘Add New’ for both hierarchical and non-hierarchical types.
  addNew: String

  # Label for adding a new singular item.
  addNewItem: String

  # Label to signify all items in a submenu link.
  allItems: String

  # Label for archives in nav menus
  archives: String

  # Label for the attributes meta box.
  attributes: String

  # Label for editing a singular item.
  editItem: String

  # Label for the Featured Image meta box title.
  featuredImage: String

  # Label for the table views hidden heading.
  filterItemsList: String

  # Label for the media frame button.
  insertIntoItem: String

  # Label for the table hidden heading.
  itemsList: String

  # Label for the table pagination hidden heading.
  itemsListNavigation: String

  # Label for the menu name.
  menuName: String

  # General name for the post type, usually plural.
  name: String

  # Label for the new item page title.
  newItem: String

  # Label used when no items are found.
  notFound: String

  # Label used when no items are in the trash.
  notFoundInTrash: String

  # Label used to prefix parents of hierarchical items.
  parentItemColon: String

  # Label for removing the featured image.
  removeFeaturedImage: String

  # Label for searching plural items.
  searchItems: String

  # Label for setting the featured image.
  setFeaturedImage: String

  # Name for one object of this post type.
  singularName: String

  # Label for the media frame filter.
  uploadedToThisItem: String

  # Label in the media frame for using a featured image.
  useFeaturedImage: String

  # Label for viewing a singular item.
  viewItem: String

  # Label for viewing post type archives.
  viewItems: String
}

type MediaDetails {
  # The height of the mediaItem
  file: String

  # The height of the mediaItem
  height: Int
  meta: MediaItemMeta

  # The available sizes of the mediaItem
  sizes: [MediaSizes]

  # The width of the mediaItem
  width: Int
}

# The mediaItem object type
type MediaItem implements Node {
  # Alternative text to display when resource is not displayed
  altText: String

  # Ancestors of the object
  ancestors(
    # The types of ancestors to check for. Defaults to the same type as the current object
    types: [PostTypeEnum]
  ): [PostObjectUnion]

  # The author field will return a queryable User type matching the post&#039;s author.
  author: User

  # The caption for the resource
  caption: String

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # Whether the comments are open or closed for this particular post.
  commentStatus: String

  # A collection of comment objects
  comments(after: String, first: Int, before: String, last: Int, where: CommentArgs): CommentsConnection

  # The content of the post.
  content(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String @deprecated(reason: "Use the description field instead of content")

  # Post publishing date.
  date: String

  # The publishing date set in GMT.
  dateGmt: String

  # Description of the image (stored as post_content)
  description: String

  # The desired slug of the post
  desiredSlug: String

  # The user that most recently edited the object
  editLast: User

  # If a user has edited the object within the past 15 seconds, this will return
  # the user and the time they last edited. Null if the edit lock doesn&#039;t
  # exist or is greater than 15 seconds
  editLock: EditLock

  # The RSS enclosure for the object
  enclosure: String

  # The excerpt of the post. This is currently just the raw excerpt. An amendment
  # to support rendered excerpts needs to be made.
  excerpt(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String @deprecated(reason: "Use the caption field instead of excerpt")

  # The global unique identifier for this post. This currently matches the value
  # stored in WP_Post-&gt;guid and the guid column in the `post_objects` database
  guid: String

  # The globally unique ID for the object
  id: ID!

  # The permalink of the post
  link: String

  # Details about the mediaItem
  mediaDetails: MediaDetails

  # The id field matches the WP_Post-&gt;ID field.
  mediaItemId: Int!

  # Type of resource
  mediaType: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # The mime type of the mediaItem
  mimeType: String

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The parent of the object. The parent object can be of various types
  parent: PostObjectUnion

  # Whether the pings are open or closed for this particular post.
  pingStatus: String

  # URLs that have been pinged.
  pinged: [String]

  # The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name
  # field and the post_name column in the database for the `post_objects` table.
  slug: String

  # Url of the mediaItem
  sourceUrl: String

  # The current status of the object
  status: String

  # Terms connected to the mediaItem
  termNames(
    # Select which taxonomies to limit the results to
    taxonomy: TaxonomyEnum
  ): [String]

  # Terms connected to the mediaItem
  terms(
    # Select which taxonomies to limit the results to
    taxonomy: [TaxonomyEnum]
  ): [TermObjectUnion]

  # The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made.
  title(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # URLs queued to be pinged.
  toPing: [String]

  # URI path for the resource
  uri: String
}

type MediaItemMeta {
  aperture: Float
  credit: String
  camera: String
  caption: String
  createdTimestamp: Int
  copyright: String
  focalLength: Int
  iso: Int
  shutterSpeed: Float
  title: String
  orientation: String
  keywords: [String]
}

# The status of the media item object.
enum MediaItemStatus {
  # Objects with the auto-draft status
  AUTO_DRAFT

  # Objects with the inherit status
  INHERIT

  # Objects with the private status
  PRIVATE

  # Objects with the trash status
  TRASH
}

# A connection to a list of items.
type MediaItemsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [MediaItemsEdge]

  # Information about the type of content being queried
  postTypeInfo: PostType

  # The nodes of the connection, without the edges
  nodes: [MediaItem]
}

# An edge in a connection
type MediaItemsEdge {
  # The item at the end of the edge
  node: MediaItem

  # A cursor for use in pagination
  cursor: String!
}

type MediaSizes {
  # The referenced size name
  name: String

  # The file of the for the referenced size
  file: String

  # The width of the for the referenced size
  width: String

  # The height of the for the referenced size
  height: String

  # The mime type of the resource
  mimeType: String

  # The url of the for the referenced size
  sourceUrl: String
}

# The MimeType of the object
enum MimeType {
  APPLICATION_JAVA
  APPLICATION_JAVASCRIPT
  APPLICATION_MSWORD
  APPLICATION_OCTET_STREAM
  APPLICATION_ONENOTE
  APPLICATION_OXPS
  APPLICATION_PDF
  APPLICATION_RAR
  APPLICATION_RTF
  APPLICATION_TTAF_XML
  APPLICATION_VND_APPLE_KEYNOTE
  APPLICATION_VND_APPLE_NUMBERS
  APPLICATION_VND_APPLE_PAGES
  APPLICATION_VND_MS_ACCESS
  APPLICATION_VND_MS_EXCEL
  APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12
  APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12
  APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12
  APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12
  APPLICATION_VND_MS_POWERPOINT
  APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12
  APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12
  APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12
  APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12
  APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12
  APPLICATION_VND_MS_PROJECT
  APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12
  APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12
  APPLICATION_VND_MS_WRITE
  APPLICATION_VND_MS_XPSDOCUMENT
  APPLICATION_VND_OASIS_OPENDOCUMENT_CHART
  APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE
  APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA
  APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS
  APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION
  APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET
  APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT
  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE
  APPLICATION_WORDPERFECT
  APPLICATION_X_7Z_COMPRESSED
  APPLICATION_X_GZIP
  APPLICATION_X_TAR
  APPLICATION_ZIP
  AUDIO_MIDI
  AUDIO_MPEG
  AUDIO_OGG
  AUDIO_WAV
  AUDIO_X_MATROSKA
  AUDIO_X_MS_WAX
  AUDIO_X_MS_WMA
  AUDIO_X_REALAUDIO
  IMAGE_BMP
  IMAGE_GIF
  IMAGE_JPEG
  IMAGE_PNG
  IMAGE_TIFF
  IMAGE_X_ICON
  TEXT_CALENDAR
  TEXT_CSS
  TEXT_CSV
  TEXT_PLAIN
  TEXT_RICHTEXT
  TEXT_TAB_SEPARATED_VALUES
  TEXT_VTT
  VIDEO_3GPP
  VIDEO_3GPP2
  VIDEO_AVI
  VIDEO_DIVX
  VIDEO_MP4
  VIDEO_MPEG
  VIDEO_OGG
  VIDEO_QUICKTIME
  VIDEO_WEBM
  VIDEO_X_FLV
  VIDEO_X_MATROSKA
  VIDEO_X_MS_ASF
  VIDEO_X_MS_WM
  VIDEO_X_MS_WMV
  VIDEO_X_MS_WMX
}

# An object with an ID
interface Node {
  # The id of the object
  id: ID!
}

enum Order {
  ASC
  DESC
}

enum OrderBy {
  # Order by author
  AUTHOR

  # Order by publish date
  DATE

  # Preserve the ID order given in the IN array
  IN

  # Order by last modified date
  MODIFIED

  # Preserve slug order given in the NAME_IN array
  NAME_IN

  # Order by parent ID
  PARENT

  # Order by slug
  SLUG

  # Order by title
  TITLE
}

input OrderByOptions {
  field: OrderBy!
  order: Order
}

# The page object type
type Page implements Node {
  # Ancestors of the object
  ancestors(
    # The types of ancestors to check for. Defaults to the same type as the current object
    types: [PostTypeEnum]
  ): [PostObjectUnion]

  # The author field will return a queryable User type matching the post&#039;s author.
  author: User

  # A collection of pages objects
  childPages(after: String, first: Int, before: String, last: Int, where: QueryArgs): PagesConnection

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # Whether the comments are open or closed for this particular post.
  commentStatus: String

  # A collection of comment objects
  comments(after: String, first: Int, before: String, last: Int, where: CommentArgs): CommentsConnection

  # The content of the post.
  content(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # Post publishing date.
  date: String

  # The publishing date set in GMT.
  dateGmt: String

  # The desired slug of the post
  desiredSlug: String

  # The user that most recently edited the object
  editLast: User

  # If a user has edited the object within the past 15 seconds, this will return
  # the user and the time they last edited. Null if the edit lock doesn&#039;t
  # exist or is greater than 15 seconds
  editLock: EditLock

  # The RSS enclosure for the object
  enclosure: String

  # The excerpt of the post. This is currently just the raw excerpt. An amendment
  # to support rendered excerpts needs to be made.
  excerpt(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # The featured image for the object
  featuredImage: MediaItem

  # The global unique identifier for this post. This currently matches the value
  # stored in WP_Post-&gt;guid and the guid column in the `post_objects` database
  guid: String

  # The globally unique ID for the object
  id: ID!

  # The permalink of the post
  link: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The id field matches the WP_Post-&gt;ID field.
  pageId: Int!

  # The parent of the object. The parent object can be of various types
  parent: PostObjectUnion

  # Whether the pings are open or closed for this particular post.
  pingStatus: String

  # URLs that have been pinged.
  pinged: [String]

  # The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name
  # field and the post_name column in the database for the `post_objects` table.
  slug: String

  # The current status of the object
  status: String

  # Terms connected to the page
  termNames(
    # Select which taxonomies to limit the results to
    taxonomy: TaxonomyEnum
  ): [String]

  # Terms connected to the page
  terms(
    # Select which taxonomies to limit the results to
    taxonomy: [TaxonomyEnum]
  ): [TermObjectUnion]

  # The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made.
  title(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # URLs queued to be pinged.
  toPing: [String]

  # URI path for the resource
  uri: String
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

# A connection to a list of items.
type PagesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [PagesEdge]

  # Information about the type of content being queried
  postTypeInfo: PostType

  # The nodes of the connection, without the edges
  nodes: [Page]
}

# An edge in a connection
type PagesEdge {
  # The item at the end of the edge
  node: Page

  # A cursor for use in pagination
  cursor: String!
}

# An plugin object
type Plugin implements Node {
  # Name of the plugin author(s), may also be a company name.
  author: String

  # URI for the related author(s)/company website.
  authorUri: String

  # Description of the plugin.
  description: String
  id: ID!

  # Display name of the plugin.
  name: String

  # URI for the plugin website. This is useful for directing users for support requests etc.
  pluginUri: String

  # Current version of the plugin.
  version: String
}

# A connection to a list of items.
type PluginsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [PluginsEdge]

  # The nodes of the connection, without the edges
  nodes: [Plugin]
}

# An edge in a connection
type PluginsEdge {
  # The item at the end of the edge
  node: Plugin

  # A cursor for use in pagination
  cursor: String!
}

# The post object type
type Post implements Node {
  # Ancestors of the object
  ancestors(
    # The types of ancestors to check for. Defaults to the same type as the current object
    types: [PostTypeEnum]
  ): [PostObjectUnion]

  # The author field will return a queryable User type matching the post&#039;s author.
  author: User

  # A collection of categories objects
  categories(after: String, first: Int, before: String, last: Int, where: TermArgs): CategoriesConnection

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # Whether the comments are open or closed for this particular post.
  commentStatus: String

  # A collection of comment objects
  comments(after: String, first: Int, before: String, last: Int, where: CommentArgs): CommentsConnection

  # The content of the post.
  content(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # Post publishing date.
  date: String

  # The publishing date set in GMT.
  dateGmt: String

  # The desired slug of the post
  desiredSlug: String

  # The user that most recently edited the object
  editLast: User

  # If a user has edited the object within the past 15 seconds, this will return
  # the user and the time they last edited. Null if the edit lock doesn&#039;t
  # exist or is greater than 15 seconds
  editLock: EditLock

  # The RSS enclosure for the object
  enclosure: String

  # The excerpt of the post. This is currently just the raw excerpt. An amendment
  # to support rendered excerpts needs to be made.
  excerpt(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # The featured image for the object
  featuredImage: MediaItem

  # The global unique identifier for this post. This currently matches the value
  # stored in WP_Post-&gt;guid and the guid column in the `post_objects` database
  guid: String

  # The globally unique ID for the object
  id: ID!

  # The permalink of the post
  link: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The parent of the object. The parent object can be of various types
  parent: PostObjectUnion

  # Whether the pings are open or closed for this particular post.
  pingStatus: String

  # URLs that have been pinged.
  pinged: [String]

  # The id field matches the WP_Post-&gt;ID field.
  postId: Int!

  # The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name
  # field and the post_name column in the database for the `post_objects` table.
  slug: String

  # The current status of the object
  status: String

  # A collection of tags objects
  tags(after: String, first: Int, before: String, last: Int, where: TermArgs): TagsConnection

  # Terms connected to the post
  termNames(
    # Select which taxonomies to limit the results to
    taxonomy: TaxonomyEnum
  ): [String]

  # Terms connected to the post
  terms(
    # Select which taxonomies to limit the results to
    taxonomy: [TaxonomyEnum]
  ): [TermObjectUnion]

  # The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made.
  title(
    # Format of the field output
    format: PostObjectFieldFormat
  ): String

  # URLs queued to be pinged.
  toPing: [String]

  # URI path for the resource
  uri: String
}

# The format of post field data.
enum PostObjectFieldFormat {
  # Provide the field value directly from database
  RAW

  # Apply the default WordPress rendering
  RENDERED
}

union PostObjectUnion = Post | Page | MediaItem

# The status of the object.
enum PostStatusEnum {
  # Objects with the auto-draft status
  AUTO_DRAFT

  # Objects with the draft status
  DRAFT

  # Objects with the future status
  FUTURE

  # Objects with the inherit status
  INHERIT

  # Objects with the pending status
  PENDING

  # Objects with the private status
  PRIVATE

  # Objects with the publish status
  PUBLISH

  # Objects with the trash status
  TRASH
}

# An Post Type object
type PostType implements Node {
  # Whether this content type should can be exported.
  canExport: Boolean

  # List of Taxonomies connected to the Post Type
  connectedTaxonomies(
    # Select which taxonomies to limit the results to
    taxonomies: [TaxonomyEnum]
  ): [Taxonomy]

  # A list of Taxonomies associated with the post type
  connectedTaxonomyNames(
    # Select which taxonomies to limit the results to
    taxonomies: [TaxonomyEnum]
  ): [String]

  # Whether delete this type of content when the author of it is deleted from the system.
  deleteWithUser: Boolean

  # Description of the content type.
  description: String

  # Whether to exclude posts with this post type from front end search results.
  excludeFromSearch: Boolean

  # The plural name of the post type within the GraphQL Schema.
  graphqlPluralName: String

  # The singular name of the post type within the GraphQL Schema.
  graphqlSingleName: String

  # Whether this content type should have archives. Content archives are generated by type and by date.
  hasArchive: Boolean

  # Whether the post type is hierarchical, for example pages.
  hierarchical: Boolean
  id: ID!

  # Display name of the content type.
  label: String

  # Details about the post type labels.
  labels: LabelsDetails

  # The name of the icon file to display as a menu icon.
  menuIcon: String

  # The position of this post type in the menu. Only applies if show_in_menu is true.
  menuPosition: Int

  # The internal name of the post type. This should not be used for display purposes.
  name: String

  # Whether a post type is intended for use publicly either via the admin
  # interface or by front-end users. While the default settings of
  # exclude_from_search, publicly_queryable, show_ui, and show_in_nav_menus are
  # inherited from public, each does not rely on this relationship and controls a
  # very specific intention.
  public: Boolean

  # Whether queries can be performed on the front end for the post type as part of parse_request().
  publiclyQueryable: Boolean

  # Name of content type to diplay in REST API `wp/v2` namespace.
  restBase: String

  # The REST Controller class assigned to handling this content type.
  restControllerClass: String

  # Makes this post type available via the admin bar.
  showInAdminBar: Boolean

  # Whether to add the post type to the GraphQL Schema.
  showInGraphql: Boolean

  # Where to show the post type in the admin menu. To work, $show_ui must be true.
  # If true, the post type is shown in its own top level menu. If false, no menu
  # is shown. If a string of an existing top level menu (eg. &quot;tools.php&quot;
  # or &quot;edit.php?post_type=page&quot;), the post type will be placed as a
  # sub-menu of that.
  showInMenu: Boolean

  # Makes this post type available for selection in navigation menus.
  showInNavMenus: Boolean

  # Whether to add the post type route in the REST API `wp/v2` namespace.
  showInRest: Boolean

  # Whether to generate and allow a UI for managing this post type in the admin.
  showUi: Boolean
}

# Allowed Post Types
enum PostTypeEnum {
  POST
  PAGE
  MEDIAITEM
}

# A connection to a list of items.
type PostsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [PostsEdge]

  # Information about the type of content being queried
  postTypeInfo: PostType

  # The nodes of the connection, without the edges
  nodes: [Post]
}

# An edge in a connection
type PostsEdge {
  # The item at the end of the edge
  node: Post

  # A cursor for use in pagination
  cursor: String!
}

input QueryArgs {
  # The user that's connected as the author of the object. Use the 
  # 							userId for the author object.
  author: Int

  # Find objects connected to author(s) in the array of author's userIds
  authorIn: [ID]

  # Find objects connected to the author by the author's "nicename"
  authorName: String

  # Find objects NOT connected to author(s) in the array of author's 
  # 							userIds
  authorNotIn: [Int]

  # Category ID
  categoryId: Int

  # Array of category IDs, used to display objects from one 
  # 										category OR another
  categoryIn: [Int]

  # Use Category Slug
  categoryName: String
  dateQuery: DateQuery

  # True for objects with passwords; False for objects without passwords; 
  # 							null for all objects with or without passwords
  hasPassword: String

  # Specific ID of the object
  id: Int

  # Array of IDs for the objects to retrieve
  in: [Int]

  # Get objects with a specific mimeType property
  mimeType: MimeType

  # Slug / post_name of the object
  name: String

  # Specify objects to retrieve. Use slugs
  nameIn: [String]

  # Specify IDs NOT to retrieve. If this is used in the same query as "in", 
  # 							it will be ignored
  notIn: [Int]

  # What paramater to use to order the objects by.
  orderby: [OrderByOptions]

  # Use ID to return only children. Use 0 to return only top-level 
  # 							items
  parent: String

  # Specify objects whose parent is in an array
  parentIn: [Int]

  # Specify posts whose parent is not in an array
  parentNotIn: [Int]

  # Show posts with a specific password.
  password: String

  # Show Posts based on a keyword search
  search: String
  status: PostStatusEnum

  # Tag Slug
  tag: String

  # Use Tag ID
  tagId: String

  # Array of tag IDs, used to display objects from one tag OR 
  # 							another
  tagIn: [Int]

  # Array of tag slugs, used to display objects from one tag OR 
  # 							another
  tagSlugAnd: [String]

  # Array of tag slugs, used to exclude objects in specified 
  # 							tags
  tagSlugIn: [String]

  # Title of the object
  title: String
}

# The logical relation between each item in the array when there are more than one.
enum RelationEnum {
  AND
  OR
}

# The root mutation
type RootMutation {
  createCategory(input: CreateCategoryInput!): CreateCategoryPayload
  createMediaItem(input: CreateMediaItemInput!): CreateMediaItemPayload
  createPage(input: CreatePageInput!): CreatePagePayload
  createPost(input: CreatePostInput!): CreatePostPayload
  createTag(input: CreateTagInput!): CreateTagPayload
  createUser(input: CreateUserInput!): CreateUserPayload
  deleteCategory(input: DeleteCategoryInput!): DeleteCategoryPayload
  deleteMediaItem(input: DeleteMediaItemInput!): DeleteMediaItemPayload
  deletePage(input: DeletePageInput!): DeletePagePayload
  deletePost(input: DeletePostInput!): DeletePostPayload
  deleteTag(input: DeleteTagInput!): DeleteTagPayload
  deleteUser(input: DeleteUserInput!): DeleteUserPayload
  updateCategory(input: UpdateCategoryInput!): UpdateCategoryPayload
  updateMediaItem(input: UpdateMediaItemInput!): UpdateMediaItemPayload
  updatePage(input: UpdatePageInput!): UpdatePagePayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
}

type RootQuery {
  # A collection of categories objects
  categories(after: String, first: Int, before: String, last: Int, where: TermArgs): CategoriesConnection

  # A 0bject
  category(id: ID!): Category

  # Returns a Comment
  comment(id: ID!): Comment

  # A collection of comment objects
  comments(after: String, first: Int, before: String, last: Int, where: CommentArgs): CommentsConnection

  # A 0bject
  mediaItem(id: ID!): MediaItem

  # A mediaItem object
  mediaItemBy(
    # Get the object by it's global ID
    id: String

    # Get the mediaItem by it's database ID
    mediaItemId: Int

    # Get the mediaItem by it's slug (only available for non-hierarchical types)
    slug: String

    # Get the mediaItem by it's uri
    uri: String
  ): MediaItem

  # A collection of mediaItems objects
  mediaItems(after: String, first: Int, before: String, last: Int, where: QueryArgs): MediaItemsConnection

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node

  # A 0bject
  page(id: ID!): Page

  # A page object
  pageBy(
    # Get the object by it's global ID
    id: String

    # Get the page by it's database ID
    pageId: Int

    # Get the page by it's uri
    uri: String
  ): Page

  # A collection of pages objects
  pages(after: String, first: Int, before: String, last: Int, where: QueryArgs): PagesConnection

  # A WordPress plugin
  plugin(id: ID!): Plugin

  # A collection of plugins
  plugins(after: String, first: Int, before: String, last: Int): PluginsConnection

  # A 0bject
  post(id: ID!): Post

  # A post object
  postBy(
    # Get the object by it's global ID
    id: String

    # Get the post by it's database ID
    postId: Int

    # Get the post by it's slug (only available for non-hierarchical types)
    slug: String

    # Get the post by it's uri
    uri: String
  ): Post

  # A collection of posts objects
  posts(after: String, first: Int, before: String, last: Int, where: QueryArgs): PostsConnection

  # A 0bject
  tag(id: ID!): Tag

  # A collection of tags objects
  tags(after: String, first: Int, before: String, last: Int, where: TermArgs): TagsConnection

  # A Theme object
  theme(id: ID!): Theme

  # A collection of theme objects
  themes(after: String, first: Int, before: String, last: Int): ThemesConnection

  # Returns a user
  user(id: ID!): User

  # A collection of user objects
  users(after: String, first: Int, before: String, last: Int, where: UserArgs): UsersConnection

  # Returns the current user
  viewer: User
}

enum SearchColumnsEnum {
  EMAIL
  ID
  LOGIN
  NICENAME
  URL
}

# The 0bject type
type Tag implements Node {
  # The number of objects connected to the object
  count: Int

  # The description of the object
  description: String

  # The global ID for the post_tag
  id: ID!

  # The link to the term
  link: String

  # The human friendly name of the object.
  name: String

  # A collection of posts objects
  posts(after: String, first: Int, before: String, last: Int, where: QueryArgs): PostsConnection

  # An alphanumeric identifier for the object unique to its type.
  slug: String

  # The id field matches the WP_Post-&gt;ID field.
  tagId: Int

  # The name of the taxonomy this term belongs to
  taxonomy: Taxonomy

  # The ID of the term group that this term object belongs to
  termGroupId: Int

  # The taxonomy ID that the object is associated with
  termTaxonomyId: Int
}

# A connection to a list of items.
type TagsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [TagsEdge]

  # Information about the type of content being queried
  taxonomyInfo: Taxonomy

  # The nodes of the connection, without the edges
  nodes: [Tag]
}

# An edge in a connection
type TagsEdge {
  # The item at the end of the edge
  node: Tag

  # A cursor for use in pagination
  cursor: String!
}

# A taxonomy object
type Taxonomy implements Node {
  # A list of Post Types associated with the taxonomy
  connectedPostTypeNames(
    # Select which post types to limit the results to
    types: [PostTypeEnum]
  ): [String]

  # List of Post Types connected to the Taxonomy
  connectedPostTypes(
    # Select which post types to limit the results to
    types: [PostTypeEnum]
  ): [PostType]

  # Description of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;description
  description: String

  # The plural name of the post type within the GraphQL Schema.
  graphqlPluralName: String

  # The singular name of the post type within the GraphQL Schema.
  graphqlSingleName: String

  # Whether the taxonomy is hierarchical
  hierarchical: Boolean
  id: ID!

  # Name of the taxonomy shown in the menu. Usually plural.
  label: String

  # The display name of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;label
  name: String

  # Whether the taxonomy is publicly queryable
  public: Boolean

  # Name of content type to diplay in REST API `wp/v2` namespace.
  restBase: String

  # The REST Controller class assigned to handling this content type.
  restControllerClass: String

  # Whether to show the taxonomy as part of a tag cloud widget. This field is equivalent to WP_Taxonomy-&gt;show_tagcloud
  showCloud: Boolean

  # Whether to display a column for the taxonomy on its post type listing screens.
  showInAdminColumn: Boolean

  # Whether to add the post type to the GraphQL Schema.
  showInGraphql: Boolean

  # Whether to show the taxonomy in the admin menu
  showInMenu: Boolean

  # Whether the taxonomy is available for selection in navigation menus.
  showInNavMenus: Boolean

  # Whether to show the taxonomy in the quick/bulk edit panel.
  showInQuickEdit: Boolean

  # Whether to add the post type route in the REST API `wp/v2` namespace.
  showInRest: Boolean

  # Whether to generate and allow a UI for managing terms in this taxonomy in the admin
  showUi: Boolean
}

# Allowed taxonomies
enum TaxonomyEnum {
  CATEGORY
  TAG
}

input TermArgs {
  # Unique cache key to be produced when this query is stored in an object cache. Default is 'core'.
  cacheDomain: String

  # Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0.
  childOf: Int

  # True to limit results to terms that have no children. This parameter has no
  # effect on non-hierarchical taxonomies. Default false.
  childless: Boolean

  # Retrieve terms where the description is LIKE `$description__like`. Default empty.
  descriptionLike: String

  # Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array.
  exclude: [Int]

  # Array of term ids to exclude along with all of their descendant terms. If
  # $include is non-empty, $exclude_tree is ignored. Default empty array.
  excludeTree: [Int]

  # Whether to hide terms not assigned to any posts. Accepts true or false. Default true
  hideEmpty: Boolean

  # Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true.
  hierarchical: Boolean

  # Array of term ids to include. Default empty array.
  include: [Int]

  # Array of names to return term(s) for. Default empty.
  name: [String]

  # Retrieve terms with criteria by which a term is LIKE `$name__like`. Default empty.
  nameLike: String

  # Array of object IDs. Results will be limited to terms associated with these objects.
  objectIds: [Int]

  # Field(s) to order terms by. Defaults to 'name'.
  orderby: TermsOrderby

  # Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false.
  padCounts: Boolean

  # Parent term ID to retrieve direct-child terms of. Default empty.
  parent: Int

  # Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty.
  search: String

  # Array of slugs to return term(s) for. Default empty.
  slug: [String]

  # Array of term taxonomy IDs, to match when querying terms.
  termTaxonomId: [Int]

  # Whether to prime meta caches for matched terms. Default true.
  updateTermMetaCache: Boolean
}

union TermObjectUnion = Category | Tag

enum TermsOrderby {
  COUNT
  DESCRIPTION
  NAME
  SLUG
  TERM_GROUP
  TERM_ID
}

# A theme object
type Theme implements Node {
  # Name of the theme author(s), could also be a company name. This field is
  # equivalent to WP_Theme-&gt;get( &quot;Author&quot; ).
  author: String

  # URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;AuthorURI&quot; ).
  authorUri: String

  # The description of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Description&quot; ).
  description: String
  id: ID!

  # Display name of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Name&quot; ).
  name: String

  # The URL of the screenshot for the theme. The screenshot is intended to give an
  # overview of what the theme looks like. This field is equivalent to
  # WP_Theme-&gt;get_screenshot().
  screenshot: String

  # The theme slug is used to internally match themes. Theme slugs can have
  # subdirectories like: my-theme/sub-theme. This field is equivalent to
  # WP_Theme-&gt;get_stylesheet().
  slug: String

  # URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;Tags&quot; ).
  tags: [String]

  # A URI if the theme has a website associated with it. The Theme URI is handy
  # for directing users to a theme site for support etc. This field is equivalent
  # to WP_Theme-&gt;get( &quot;ThemeURI&quot; ).
  themeUri: String

  # The current version of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Version&quot; ).
  version: Float
}

# A connection to a list of items.
type ThemesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [ThemesEdge]

  # The nodes of the connection, without the edges
  nodes: [Theme]
}

# An edge in a connection
type ThemesEdge {
  # The item at the end of the edge
  node: Theme

  # A cursor for use in pagination
  cursor: String!
}

input UpdateCategoryInput {
  # The name of the category object to mutate
  name: String

  # The ID of the category object to update
  id: ID!

  # The slug that the category will be an alias of
  aliasOf: String

  # The description of the category object
  description: String

  # If this argument exists then the slug will be checked to see if it is not an
  # existing valid term. If that check succeeds (it is not a valid term), then it
  # is added and the term id is given. If it fails, then a check is made to
  # whether the taxonomy is hierarchical and the parent argument is not empty. If
  # the second check succeeds, the term will be inserted and the term id will be
  # given. If the slug argument is empty, then it will be calculated from the term
  slug: String

  # The ID of the category that should be set as the parent
  parentId: ID
  clientMutationId: String!
}

type UpdateCategoryPayload {
  category: Category
  clientMutationId: String!
}

input UpdateMediaItemInput {
  # The ID of the mediaItem object
  id: ID!

  # Alternative text to display when mediaItem is not displayed
  altText: String

  # The userId to assign as the author of the mediaItem
  authorId: ID

  # The caption for the mediaItem
  caption: String

  # The comment status for the mediaItem
  commentStatus: String

  # The date of the mediaItem
  date: String

  # The date (in GMT zone) of the mediaItem
  dateGmt: String

  # Description of the mediaItem
  description: String

  # The file name of the mediaItem
  filePath: String

  # The file type of the mediaItem
  fileType: MimeType

  # The slug of the mediaItem
  slug: String

  # The status of the mediaItem
  status: MediaItemStatus

  # The title of the mediaItem
  title: String

  # The ping status for the mediaItem
  pingStatus: String

  # The WordPress post ID or the graphQL postId of the parent object
  parentId: ID
  clientMutationId: String!
}

type UpdateMediaItemPayload {
  mediaItem: MediaItem
  clientMutationId: String!
}

input UpdatePageInput {
  # The ID of the page object
  id: ID!

  # The userId to assign as the author of the post
  authorId: ID

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # The comment status for the object
  commentStatus: String

  # The content of the object
  content: String

  # The date of the object
  date: String

  # The date (in GMT zone) of the object
  dateGmt: String

  # The excerpt of the object
  excerpt: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # If the post is an attachment or a media file, this field will carry the
  # corresponding MIME type. This field is equivalent to the value of
  # WP_Post->post_mime_type and the post_mime_type column in the `post_objects`
  # database table.
  mimeType: MimeType

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The ID of the parent object
  parentId: ID

  # The password used to protect the content of the object
  password: String

  # URLs that have been pinged.
  pinged: [String]

  # The ping status for the object
  pingStatus: String

  # The slug of the object
  slug: String

  # The status of the object
  status: PostStatusEnum

  # The title of the post
  title: String

  # URLs queued to be pinged.
  toPing: [String]
  clientMutationId: String!
}

type UpdatePagePayload {
  page: Page
  clientMutationId: String!
}

input UpdatePostInput {
  # The ID of the post object
  id: ID!

  # The userId to assign as the author of the post
  authorId: ID

  # The number of comments. Even though WPGraphQL denotes this field as an
  # integer, in WordPress this field should be saved as a numeric string for
  commentCount: Int

  # The comment status for the object
  commentStatus: String

  # The content of the object
  content: String

  # The date of the object
  date: String

  # The date (in GMT zone) of the object
  dateGmt: String

  # The excerpt of the object
  excerpt: String

  # A field used for ordering posts. This is typically used with nav menu items or
  # for special ordering of hierarchical content types.
  menuOrder: Int

  # If the post is an attachment or a media file, this field will carry the
  # corresponding MIME type. This field is equivalent to the value of
  # WP_Post->post_mime_type and the post_mime_type column in the `post_objects`
  # database table.
  mimeType: MimeType

  # The local modified time for a post. If a post was recently updated the
  # modified field will change to match the corresponding time.
  modified: String

  # The GMT modified time for a post. If a post was recently updated the modified
  # field will change to match the corresponding time in GMT.
  modifiedGmt: String

  # The ID of the parent object
  parentId: ID

  # The password used to protect the content of the object
  password: String

  # URLs that have been pinged.
  pinged: [String]

  # The ping status for the object
  pingStatus: String

  # The slug of the object
  slug: String

  # The status of the object
  status: PostStatusEnum

  # The title of the post
  title: String

  # URLs queued to be pinged.
  toPing: [String]
  clientMutationId: String!
}

type UpdatePostPayload {
  post: Post
  clientMutationId: String!
}

input UpdateTagInput {
  # The name of the post_tag object to mutate
  name: String

  # The ID of the tag object to update
  id: ID!

  # The slug that the post_tag will be an alias of
  aliasOf: String

  # The description of the post_tag object
  description: String

  # If this argument exists then the slug will be checked to see if it is not an
  # existing valid term. If that check succeeds (it is not a valid term), then it
  # is added and the term id is given. If it fails, then a check is made to
  # whether the taxonomy is hierarchical and the parent argument is not empty. If
  # the second check succeeds, the term will be inserted and the term id will be
  # given. If the slug argument is empty, then it will be calculated from the term
  slug: String
  clientMutationId: String!
}

type UpdateTagPayload {
  tag: Tag
  clientMutationId: String!
}

input UpdateUserInput {
  # The ID of the user
  id: ID!

  # A string that contains the plain text password for the user.
  password: String

  # A string that contains a URL-friendly name for the user. The default is the user's username.
  nicename: String

  # A string containing the user's URL for the user's web site.
  websiteUrl: String

  # A string containing the user's email address.
  email: String

  # A string that will be shown on the site. Defaults to user's username. It is
  # likely that you will want to change this, for both appearance and security
  # through obscurity (that is if you dont use and delete the default admin user).
  displayName: String

  # The user's nickname, defaults to the user's username.
  nickname: String

  # 	The user's first name.
  firstName: String

  # The user's last name.
  lastName: String

  # A string containing content about the user.
  description: String

  # A string for whether to enable the rich editor or not. False if not empty.
  richEditing: String

  # The date the user registered. Format is Y-m-d H:i:s.
  registered: String

  # An array of roles to be assigned to the user.
  roles: [String]

  # User's Jabber account.
  jabber: String

  # User's AOL IM account.
  aim: String

  # User's Yahoo IM account.
  yim: String

  # User's locale.
  locale: String
  clientMutationId: String!
}

type UpdateUserPayload {
  # The updated user
  user: User
  clientMutationId: String!
}

# A User object
type User implements Node {
  # Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument.
  avatar(
    # The size attribute of the avatar field can be used to fetch avatars of
    # different sizes. The value corresponds to the dimension in pixels to fetch.
    # The default is 96 pixels.
    size: Int = 96

    # Whether to always show the default image, never the Gravatar. Default false
    forceDefault: Boolean
    rating: AvatarRatingEnum
  ): Avatar

  # User metadata option name. Usually it will be `wp_capabilities`.
  capKey: String

  # This field is the id of the user. The id of the user matches WP_User-&gt;ID
  # field and the value in the ID column for the `users` table in SQL.
  capabilities: [String]

  # A collection of comment objects
  comments(after: String, first: Int, before: String, last: Int, where: CommentArgs): CommentsConnection

  # Description of the user.
  description: String

  # Email of the user. This is equivalent to the WP_User-&gt;user_email property.
  email: String

  # A complete list of capabilities including capabilities inherited from a role.
  # This is equivalent to the array keys of WP_User-&gt;allcaps.
  extraCapabilities: [String]

  # First name of the user. This is equivalent to the WP_User-&gt;user_first_name property.
  firstName: String

  # The globally unique identifier for the user
  id: ID!

  # Last name of the user. This is equivalent to the WP_User-&gt;user_last_name property.
  lastName: String

  # The preferred language locale set for the user. Value derived from get_user_locale().
  locale: String

  # A collection of mediaItems objects
  mediaItems(after: String, first: Int, before: String, last: Int, where: QueryArgs): MediaItemsConnection

  # Display name of the user. This is equivalent to the WP_User-&gt;dispaly_name property.
  name: String

  # The nicename for the user. This field is equivalent to WP_User-&gt;user_nicename
  nicename: String

  # Nickname of the user.
  nickname: String

  # A collection of pages objects
  pages(after: String, first: Int, before: String, last: Int, where: QueryArgs): PagesConnection

  # A collection of posts objects
  posts(after: String, first: Int, before: String, last: Int, where: QueryArgs): PostsConnection

  # The date the user registered or was created. The field follows a full ISO8601 date string format.
  registeredDate: String

  # A list of roles that the user has. Roles can be used for querying for certain
  # types of users, but should not be used in permissions checks.
  roles: [String]

  # The slug for the user. This field is equivalent to WP_User-&gt;user_nicename
  slug: String

  # A website url that is associated with the user.
  url: String

  # The Id of the user. Equivelant to WP_User-&gt;ID
  userId: Int

  # Username for the user. This field is equivalent to WP_User-&gt;user_login.
  username: String
}

input UserArgs {
  # Array of IDs of users whose unapproved comments will be returned by the query regardless of status.
  exclude: [Int]

  # Pass an array of post types to filter results to users who have published posts in those post types.
  hasPublishedPosts: [PostTypeEnum]

  # Array of comment IDs to include.
  include: [Int]

  # The user login.
  login: String

  # An array of logins to include. Users matching one of these logins will be included in results.
  loginIn: Int

  # An array of logins to exclude. Users matching one of these logins will not be included in results.
  loginNotIn: Int

  # The user nicename.
  nicename: Int

  # An array of nicenames to include. Users matching one of these nicenames will be included in results.
  nicenameIn: [String]

  # An array of nicenames to exclude. Users matching one of these nicenames will not be included in results.
  nicenameNotIn: [String]

  # An array of role names that users must match to be included in results. Note
  # that this is an inclusive list: users must match *each* role.
  role: UserRoleEnum

  # An array of role names. Matched users must have at least one of these roles.
  roleIn: [UserRoleEnum]

  # An array of role names to exclude. Users matching one or more of these roles will not be included in results.
  roleNotIn: [UserRoleEnum]

  # Search keyword. Searches for possible string matches on columns. When
  # `searchColumns` is left empty, it tries to determine which column to search in
  # based on search string.
  search: String

  # Array of column names to be searched. Accepts 'ID', 'login', 'nicename', 'email', 'url'.
  searchColumns: [SearchColumnsEnum]
}

enum UserRoleEnum {
  ADMINISTRATOR
  AUTHOR
  CONTRIBUTOR
  EDITOR
  SUBSCRIBER
}

# A connection to a list of items.
type UsersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination
  edges: [UsersEdge]

  # The nodes of the connection, without the edges
  nodes: [User]
}

# An edge in a connection
type UsersEdge {
  # The item at the end of the edge
  node: User

  # A cursor for use in pagination
  cursor: String!
}
